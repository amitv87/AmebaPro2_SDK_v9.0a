#include "flash_api.h"
#include "autoconf.h"

//#if defined(CONFIG_FTL_ENABLED)
const u32 ftl_phy_page_start_addr = 0x00100000;

#define FTL_TEST_SIZE	256

u8 autotest_map[FTL_TEST_SIZE] = {
	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,   0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0,
	0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,   0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1,
	0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,   0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2,
	0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,   0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3,
	0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,   0x84, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4,
	0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,   0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5,
	0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,   0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6,
	0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,   0x87, 0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7,
	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,   0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0,
	0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,   0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1,
	0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,   0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2,
	0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,   0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3,
	0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,   0x84, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4,
	0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,   0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5,
	0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,   0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6,
	0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,   0x87, 0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7,
};

u8 reset_map[FTL_TEST_SIZE] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

void dump_logical_map(void)
{
	u32 index;
	u8 logical_map[16];

	for (index = 0; index < FTL_TEST_SIZE; index += 16) {
		ftl_load_from_storage(logical_map, index, 16);

		MONITOR_LOG("LogMap[%03x]: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", index,
					logical_map[0], logical_map[1], logical_map[2], logical_map[3],
					logical_map[4], logical_map[5], logical_map[6], logical_map[7],
					logical_map[8], logical_map[9], logical_map[10], logical_map[11],
					logical_map[12], logical_map[13], logical_map[14], logical_map[15]);
	}
}

void dump_physical_map(u8 page_index, u16 byte_idx)
{
	u32 index;
	u8 *ptr = SPI_FLASH_BASE + ftl_phy_page_start_addr + 0x1000 * page_index;

	printf("Start Addr:0x%x\n", (u32)ptr + byte_idx);
	for (index = byte_idx; index < 0x1000 / 4 + byte_idx; index += 16) {
		MONITOR_LOG("RawMap[%03x]: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", index,
					ptr[index], ptr[index + 1], ptr[index + 2], ptr[index + 3],
					ptr[index + 4], ptr[index + 5], ptr[index + 6], ptr[index + 7],
					ptr[index + 8], ptr[index + 9], ptr[index + 10], ptr[index + 11],
					ptr[index + 12], ptr[index + 13], ptr[index + 14], ptr[index + 15]);
	}
}

u8 _char2num(u8 ch)
{
	if ((ch >= '0') && (ch <= '9')) {
		return ch - '0';
	} else if ((ch >= 'a') && (ch <= 'f')) {
		return ch - 'a' + 10;
	} else if ((ch >= 'A') && (ch <= 'F')) {
		return ch - 'A' + 10;
	} else {
		return 0xff;
	}
}

u8 _2char2hex(u8 hch, u8 lch)
{
	return ((_char2num(hch) << 4) | _char2num(lch));
}
u32 CmdFtlTest(IN  u16 argc, IN  u8  *argv[])
{
	u8 tmp_buf[FTL_TEST_SIZE];
	u32 index;
	BOOL res;

	if (strcmp(argv[0], "wmap") == 0) {

		u32 Addr = strtoul((const u8 *)(argv[1]), (u8 **)NULL, 16);
		u32 Len = strtoul((const u8 *)(argv[2]), (u8 **)NULL, 16);
		char *DString = argv[3];
		u32 Cnt;

		Cnt = strlen(DString);
		if (Cnt % 2) {
			printf("string length(%d) should be odd \n", Cnt);
			return FALSE;
		}

		Cnt = Cnt / 2;
		if (Cnt != Len) {
			printf("Oops: write lenth not match input string lentg, choose smaller one\n");
			Len = (Cnt < Len) ? Cnt : Len;
		}

		printf("FTL wmap write len:%d, string len:%d\n", Len, Cnt << 1);

		for (index = 0; index < Len; index++) {
			tmp_buf[index] = _2char2hex(DString[index * 2], DString[index * 2 + 1]);
		}

		printf("result:%d\n\r", ftl_save_to_storage(tmp_buf, Addr, Len));

	} else if (strcmp(argv[0], "wmap_all") == 0) {

		printf("FTL wmap_all test\n");

		ftl_save_to_storage(autotest_map, 0, FTL_TEST_SIZE);

		ftl_load_from_storage(tmp_buf, 0, FTL_TEST_SIZE);

		if (memcmp(autotest_map, tmp_buf, FTL_TEST_SIZE) == 0) {
			printf("FTL wmap_all test OK\n");
		} else {
			printf("FTL wmap_all test Fail\n");
		}

	} else if (strcmp(argv[0], "gc") == 0) {
		printf("FTL garbage collection test\n");

		for (index = 0; index < 15; index++) {
			ftl_save_to_storage(reset_map, 0, FTL_TEST_SIZE);
			ftl_save_to_storage(autotest_map, 0, FTL_TEST_SIZE);
		}

	} else if (strcmp(argv[0], "dump") == 0) {
		if (strcmp(argv[1], "log") == 0) {
			dump_logical_map();
		} else if (strcmp(argv[1], "phy") == 0) {
			u8 page_idx = strtoul((const u8 *)(argv[2]), (u8 **)NULL, 10);
			u16 byte_idx = strtoul((const u8 *)(argv[3]), (u8 **)NULL, 16);

			dump_physical_map(page_idx, byte_idx);
		}

	}
}


//CMD_TABLE_DATA_SECTION
//const COMMAND_TABLE   ftl_test_cmd_table[] = {
//	{(const u8 *)"FTL",  8, CmdFtlTest, (const u8 *)"TODO \n"},
//};

//#endif

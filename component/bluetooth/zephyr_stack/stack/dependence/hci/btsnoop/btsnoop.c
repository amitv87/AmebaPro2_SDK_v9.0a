#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include <zephyr/types.h>
#include <kernel.h>
#include <kernel_structs.h>
#include <btsnoop.h>
#include <btsnoop_uart.h>

#define BTSNOOP_TX  PA_3 
#define BTSNOOP_RX  PA_2 
#define BTSNOOP_UART_BAUDRATE 1500000
/* the default timestamp is 2000,1,1,0:0:0 */
#define DEFAULT_BTSNOOP_TIMESTAMP 0x00E03AB44A676000

#define MSG_TAG_PACKET          0
#define MSG_TAG_THREAD_DEL   0xFF

static uint8_t PKT_Head_Flag[6] = {0xA5, 0x5A, 0xC3, 0x3C, 0x5C, 0xC5};
static uint8_t PKT_Tail_Flag[2] = {0x3A, 0xA3};

/* the time generated by board when the board receive the base timestamp from host computer */
volatile uint64_t btsnoop_start_time = 0;
/* the base timestamp received from host computer */
volatile uint64_t btsnoop_base_timestamp = DEFAULT_BTSNOOP_TIMESTAMP;
/* the base timestamp received from host computer last time */
volatile uint64_t btsnoop_base_timestamp_old = DEFAULT_BTSNOOP_TIMESTAMP;

struct btsnoop_pkt {
	uint32_t origin_length;
	uint32_t included_length;
	uint32_t flags;
	uint32_t drops;
	uint64_t timestamp;
	uint8_t data[260];
} __packed;

typedef struct {
    uint8_t *pkt_ptr;
    uint16_t pkt_len;
} BTSNP_TX_THREAD_BUF;

typedef struct {
    struct k_thread thread_data;
    k_msg_queue thread_queue;
} BTSNP_TX_THREAD_INFO;

// BTSNOOP_UART_INFO btsnoop_uart_info;
BTSNP_TX_THREAD_INFO btsnoop_tx_thread_info;
// serial_t btsnoop_sobj;

uint32_t htonl(uint32_t hl)
{
#ifdef CONFIG_ENDIAN_BIG
  return hl;
#else
  return (((hl) >> 24) |
          (((hl) >>  8) & 0x0000ff00) |
          (((hl) <<  8) & 0x00ff0000) |
           ((hl) << 24));
#endif
}

uint32_t ntohl(uint32_t nl)
{
#ifdef CONFIG_ENDIAN_BIG
  return nl;
#else
  return htonl(nl);
#endif
}

uint64_t htonll(uint64_t hl)
{
#ifdef CONFIG_ENDIAN_BIG
  return hl;
#else
  return (((hl) >> 56) |
          (((hl) >> 40) & 0x000000000000ff00) |
          (((hl) >> 24) & 0x0000000000ff0000) |
          (((hl) >>  8) & 0x00000000ff000000) |
          (((hl) <<  8) & 0x000000ff00000000) |
          (((hl) << 24) & 0x0000ff0000000000) |
          (((hl) << 40) & 0x00ff000000000000) |
          ((hl) << 56));
#endif
}

uint64_t ntohll(uint64_t nl)
{
#ifdef CONFIG_ENDIAN_BIG
  return nl;
#else
  return htonll(nl);
#endif
}

extern int64_t k_uptime_get(void);

// static void btsnoop_uart_irq(uint32_t id, SerialIrq event)
// {
//     serial_t* serial_obj = (void *)id;
// 	int max_count = 16;
// 	uint8_t ch, *buf_ptr;
//     uint64_t timestamp_temp = 0;

//     if (event == RxIrq) {
//         btsnoop_uart_info.rx_intr_flag = 2;
//         do {
//             ch = serial_getc(serial_obj);
//             // printf("ch[%d] is %d\n", btsnoop_uart_info.rx_buffer_cnt, ch);
//             btsnoop_uart_info.rx_buffer[btsnoop_uart_info.rx_buffer_cnt++] = ch;
//         } while (serial_readable(serial_obj) && max_count-- > 0);

//         buf_ptr = btsnoop_uart_info.rx_buffer;
//         if (buf_ptr[0] == 't' && buf_ptr[1] == 'i' && buf_ptr[2] == 'm' && buf_ptr[3] == 'e' \
//             && btsnoop_uart_info.rx_buffer_cnt >= 12) {
//             memcpy(&timestamp_temp, buf_ptr+4, 8);
//             btsnoop_base_timestamp = timestamp_temp;
//             btsnoop_start_time = (uint64_t)k_uptime_get();
//             // printf("Update the timestamp in interrupt!!\n");
//             // printf("Old is 0x%08x, 0x%08x\n", (int)(btsnoop_base_timestamp_old >>32), (int)btsnoop_base_timestamp_old);
//             // printf("New is 0x%08x, 0x%08x\n", (int)(btsnoop_base_timestamp >>32), (int)btsnoop_base_timestamp);
//             btsnoop_uart_info.rx_buffer_cnt = 0;
//             memset(buf_ptr, 0, 16);
//         }
//     }
// }

// static void btsnoop_uart_init(void)
// {
//     printf("[BTSNOOP] btsnoop_uart_init: BTSNOOP UART OPEN\r\n");
//     hal_pinmux_unregister(BTSNOOP_TX, 0x01 << 4);
//     hal_pinmux_unregister(BTSNOOP_RX, 0x01 << 4);
//     hal_gpio_pull_ctrl(BTSNOOP_TX, 0);
//     hal_gpio_pull_ctrl(BTSNOOP_RX, 0);

//     memset(&btsnoop_uart_info, 0 ,sizeof(btsnoop_uart_info));
//     serial_init(&btsnoop_sobj, BTSNOOP_TX, BTSNOOP_RX);
//     serial_baud(&btsnoop_sobj, BTSNOOP_UART_BAUDRATE);
//     serial_format(&btsnoop_sobj, 8, ParityNone, 1);
// }



// static void btsnoop_uart_deinit(void)
// {
//     serial_free(&btsnoop_sobj);
// }

// static int btsnoop_uart_tx(uint8_t *data, uint16_t len)
// {
// #if 0
//     int ret;
//     ret = serial_send_stream(&btsnoop_sobj, (char *)data, len);
//     if (ret != 0){
//         printf("[BTSNOOP] btsnoop_uart_tx_stream not corret, send fail!!!\n");
//     }
//     return ret;
// #else
//     serial_send_blocked(&btsnoop_sobj, (char *)data, len, len);
//     return 1;
// #endif
// }

// static int btsnoop_uart_rx(uint8_t *buf, uint16_t len)
// {
//     int ret;
//     ret = serial_recv_blocked(&btsnoop_sobj, (char *)buf, len, 500+len);
//     return ret;
// }

#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
static void btsnoop_tx_thread(void *p1, void *p2, void *p3)
{
    k_tx_message_t tx_message;
    BTSNP_TX_THREAD_BUF *buf;

    while (1) {
        if (k_msg_recv(&(btsnoop_tx_thread_info.thread_queue), &tx_message, K_FOREVER) == 0) {
            if (tx_message.tag == MSG_TAG_THREAD_DEL){
                goto thread_exit;
            }
            buf = (BTSNP_TX_THREAD_BUF *)(tx_message.pointer);
            btsnoop_uart_tx(PKT_Head_Flag, 6);
            btsnoop_uart_tx((uint8_t *)buf->pkt_ptr, buf->pkt_len);
            btsnoop_uart_tx(PKT_Tail_Flag, 2);
            k_free(buf->pkt_ptr);
            k_free(buf);
            continue;
        }
        
        k_yield();
    }

thread_exit:
    ;
}
#endif

void update_tmstp(uint64_t new_tmstp)
{
    btsnoop_base_timestamp = new_tmstp;
    btsnoop_start_time = (uint64_t)k_uptime_get();
}

void btsnoop_init(void)
{
    int ret, len;

    btsnoop_uart_init();
    btsnoop_uart_tx((uint8_t *)"start", 5);
    len = sizeof(btsnoop_base_timestamp);
    ret = btsnoop_uart_rx((uint8_t *)&btsnoop_base_timestamp, len);
    if (ret != len) {
        printf("[BTSNOOP] The btsnoop uart can't receive initial timestamp from host\n");
        printf("[BTSNOOP] Use the default timestamp\n");
        btsnoop_base_timestamp = DEFAULT_BTSNOOP_TIMESTAMP;
    }

    btsnoop_uart_setirq(update_tmstp);

#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
    k_msg_init(&(btsnoop_tx_thread_info.thread_queue), 20, sizeof(k_tx_message_t));
    k_thread_create(&(btsnoop_tx_thread_info.thread_data), 512, 512, btsnoop_tx_thread, NULL, NULL, NULL, K_PRIO_COOP(5), 0, K_NO_WAIT);
    printf("[BTSNOOP] Create the btsnoop tx thread\n");
#endif
}

#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
static void btsnoop_tx_thread_del(void)
{
    k_msg_send(&(btsnoop_tx_thread_info.thread_queue), NULL, MSG_TAG_THREAD_DEL, K_NO_WAIT);
}
#endif

void btsnoop_deinit(void)
{
#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
    btsnoop_tx_thread_del();
    k_msg_free(&(btsnoop_tx_thread_info.thread_queue));
#endif
    btsnoop_uart_deinit();
}

static void btsnoop_tx(uint8_t *pkt_ptr, uint16_t pkt_len)
{
#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
    BTSNP_TX_THREAD_BUF *msg_buf = k_malloc(sizeof(BTSNP_TX_THREAD_BUF));
    msg_buf->pkt_ptr = pkt_ptr;
    msg_buf->pkt_len = pkt_len;
    k_msg_send(&(btsnoop_tx_thread_info.thread_queue), msg_buf, MSG_TAG_PACKET, K_NO_WAIT); 
#else
    btsnoop_uart_tx(PKT_Head_Flag, 6);
    btsnoop_uart_tx(pkt_ptr, pkt_len);
    btsnoop_uart_tx(PKT_Tail_Flag, 2);
#endif
}

static void btsnp_tmstp_update_check(void)
{
    if (btsnoop_base_timestamp > btsnoop_base_timestamp_old) {
        printf("[BTSNOOP] The btsnoop_base_timestamp has been updated!\n");
        printf("[BTSNOOP] The new btsnoop_base_timestamp is 0x%08x%08x\n",  \
                (int)(btsnoop_base_timestamp >>32), (int)btsnoop_base_timestamp);
        btsnoop_base_timestamp_old = btsnoop_base_timestamp;
    }
}

void btsnp_pkt_create_send(uint8_t dir, uint32_t h4_len, uint32_t flags, uint8_t h4_type, uint8_t *data)
{
    struct btsnoop_pkt *pkt;
    uint64_t time_interval_ms;
    uint8_t type = h4_type;
#ifdef CONFIG_BT_HCI_BTSNOOP_TASK
    pkt = k_malloc(sizeof(struct btsnoop_pkt));
#else
    struct btsnoop_pkt _pkt;
    pkt = &_pkt;
#endif
    memset(pkt, 0, sizeof(struct btsnoop_pkt));
    pkt->origin_length = htonl(h4_len);
    pkt->included_length =  pkt->origin_length;
    pkt->flags = htonl(flags);
    pkt->drops = htonl(0);
    time_interval_ms = (uint64_t)k_uptime_get() - btsnoop_start_time;
    btsnp_tmstp_update_check();
    pkt->timestamp = htonll(btsnoop_base_timestamp + time_interval_ms * 1000);
    if (dir == H4_DIR_TX) {
        memcpy((uint8_t *)&(pkt->data), data, h4_len);
    } else if (dir == H4_DIR_RX) {
        memcpy(&(pkt->data), &type, 1);
        memcpy(((uint8_t *)&(pkt->data))+1, data, h4_len - 1);
    }
    btsnoop_tx((uint8_t *)pkt, (uint16_t)(24 + h4_len));

}